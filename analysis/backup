
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.ResultSet;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.io.ObjectInputStream.GetField;
import java.net.URL;
import java.util.*;

import edu.mit.jwi.Dictionary;
import edu.mit.jwi.IDictionary;
import edu.mit.jwi.item.IIndexWord;
import edu.mit.jwi.item.ISynset;
import edu.mit.jwi.item.ISynsetID;
import edu.mit.jwi.item.IWord;
import edu.mit.jwi.item.IWordID;
import edu.mit.jwi.item.POS;
import edu.mit.jwi.item.Pointer;
import edu.mit.jwi.*;


public class Analysis	{

	LexParserObj lp;
	IDictionary dict;

	public Analysis()	{
		lp = new LexParserObj();
		String wnhome = System.getenv("WNHOME");
		String path = wnhome + File.separator + "dict";
		

		try{
			URL url = new URL("file", null, path);
			dict = new Dictionary(url);
			dict.open();
		}catch (Exception e) {  
	             e.printStackTrace();  
	    }  
		
	}

	 public HashMap toSense(HashMap gibberish) {

	 	HashMap senseMap = new HashMap();
	    Set set = gibberish.entrySet();
	    String grammar = null;
	    String word = null;
	    char code;

	    Iterator iter = set.iterator();
	    while (iter.hasNext())  {
		    Map.Entry g = (Map.Entry)iter.next();
		   // word = g.getKey().toString();
		    code = g.getValue().toString().charAt(0);
		    //System.out.println("Key: " + g.getKey() + " Value: " + g.getValue());

		    if (code == 'J')	{
		      	grammar = "ADJECTIVE";
		    }
		    else if (code == 'N')	{
		      	grammar = "NOUN";
		    }
		    else if (code == 'V')	{
		      	grammar = "VERB";
		    }
		    else if (code == 'R')	{
		      	grammar = "ADVERB";	
		    }
		    
		    senseMap.put(g.getKey(), grammar);
		    grammar = null;
	   // System.out.println(g.getValue() + " " + grammar);


	 }
	 return senseMap;
	}
	
	public static void main(String[] args) throws Exception	{

		// Connection conn = null;
  //   	Statement stmt = null;
  //   	ResultSet rs = null;
  //   	String result = "heaven";

  //       try {
  //           // The newInstance() call is a work around for some
  //           // broken Java implementations

  //           Class.forName("com.mysql.jdbc.Driver").newInstance();
  //       } catch (Exception ex) {
  //           // handle the error
  //       }

  //       try	{
  //       	conn = DriverManager.getConnection("jdbc:mysql://localhost/test?user=root&password=");
  //       }
  //       catch (SQLException ex) {
		//     // handle any errors
		//     System.out.println("SQLException: " + ex.getMessage());
		//     System.out.println("SQLState: " + ex.getSQLState());
		//     System.out.println("VendorError: " + ex.getErrorCode());
		// }

		// try	{
		// 	stmt = conn.createStatement();
		// 	rs = stmt.executeQuery("SELECT text FROM thirdyearproject.original_tweets where user_ID=72109014");

		// 	//*This while loop will get all the results
		// 	// while (rs.next())	{
		// 	// 	result = rs.getString("text");
		// 	// 	System.out.println(result);
		// 	// }

		// 	//*This one get the top row
		// 	if(rs.next())	{
		// 		result = rs.getString("text");
		// 	}


			
		// 	//don't forget to close any statements
		// 	//and close the connection
		// 	stmt.close();
		// 	conn.close();
		// }
		// catch (SQLException ex)	{
		// 	System.out.println("SQLException: " + ex.getMessage());
		//     System.out.println("SQLState: " + ex.getSQLState());
		//     System.out.println("VendorError: " + ex.getErrorCode());
		// }
		// finally {
		//     // it is a good idea to release
		//     // resources in a finally{} block
		//     // in reverse-order of their creation
		//     // if they are no-longer needed
		//     if (rs != null) {
		//         try {
		//             rs.close();
		//         } 
		//         catch (SQLException sqlEx) {
		//         	// ignore
		//         } 
		//         rs = null;
		//     }
		//    	if (stmt != null) {
		//         try {
		//             stmt.close();
		//         }
		//         catch (SQLException sqlEx) { 
		//         	//ignore
		//         } 

		//         stmt = null;
		//     }
		// }

		Analysis analyser = new Analysis();

		
		String[] testArray = new String[]{"football", "rugby", "hockey", "chocolate"};
		HashMap grammarHM = new HashMap();

		try	{
			grammarHM = analyser.lp.getTweetsFromDB();
			System.out.println("In Analysis, the HM is:\n-------------------\n" + grammarHM);
		}catch (Exception e) {  
             e.printStackTrace();  
        }  

        grammarHM = analyser.toSense(grammarHM);
        Set set = grammarHM.entrySet();

	    Iterator iter = set.iterator();
	    while (iter.hasNext())  {
	      Map.Entry g = (Map.Entry)iter.next();
	      
	      System.out.println("Key: " + g.getKey() + " Value: " + g.getValue());
	    }




		LinkedList<hypernymTreeNode> queue = new LinkedList<hypernymTreeNode>();
		 
		hypernymTreeNode current;
		hypernymTreeNode hypernymNode;
		int counter = 40;
		//String foundCategory = null;
		hypernymTree tree = new hypernymTree();
		/*
			Add to the tree
			add all the initial nodes we are looking for
			Then do loop to add all hypernyms with breadth first search
		*/
	
		IIndexWord idxWord;
		IWordID wordID;
		IWord word;

		//add the initial leaves trying to find the common ground for
		//works while guaranteed to find a common one like sport. Won't work for mass tweets
		for (int j=0; j< testArray.length; j++)	{
			//might need to change the get(0), that just gets the first one off the list
			//which isn't necessarily the one needed
			idxWord = analyser.dict.getIndexWord(testArray[j], POS.NOUN);
			wordID = idxWord.getWordIDs().get(0);
			word = analyser.dict.getWord(wordID);
			List<hypernymTreeNode> initialRoot = new ArrayList<hypernymTreeNode>(); 
			//initialRoot = new ArrayList<hypernymTreeNode>(); 
			hypernymTreeNode node = tree.addNode(word, wordID, initialRoot);
			if (node != null)	{
				initialRoot.add(node);
					
				node.addRoots(initialRoot, tree.getRoots());
				//This adds the initial leaf nodes
				queue.add(node); 
			}
		}

		tree.addRoots(tree.getNodes());
		// System.out.println("*tree roots: ");
		// tree.printTree();
		//iterate through unexpanded nodes of tree, findinig hypernyms, adding to tree
		//keep going till one is in common
		do {
			// counter--;
			// 	//System.out.println(Integer.toString(counter));

			// if (counter == 0)	{
			// 	break;
			// }

			current = (hypernymTreeNode)queue.poll();
			//remember that POS.NOUN won't always be the case. Whatever lexparser decides it is
			idxWord = analyser.dict.getIndexWord(current.getWordString(), POS.NOUN);

			//might need to change the get(0), that just gets the first one off the list
			//which isn't necessarily the one needed
			wordID = idxWord.getWordIDs().get(0);
			word = analyser.dict.getWord(wordID);
			

			//System.out.println("Hypernyms:" + "\n" + "-----------");
			ISynset synset = word.getSynset();
			List<ISynsetID> hypernyms = synset.getRelatedSynsets(Pointer.HYPERNYM);
	 		// print out each hypernym’s id and synonyms
			List<IWord> words;
			for(ISynsetID sid : hypernyms)	{

				words = analyser.dict.getSynset(sid).getWords();
				//for all the hypernyms
				for(Iterator<IWord> i = words.iterator(); i.hasNext();)	{
					word = i.next();
					idxWord = analyser.dict.getIndexWord(word.getLemma(), POS.NOUN);
					wordID = idxWord.getWordIDs().get(0);
					word = analyser.dict.getWord(wordID);
					//System.out.println("Investigating: " + wordID);

					hypernymNode = tree.addHypernym(word, wordID, current, current.getRoots());

					if (tree.getCategory() != null)	{
						break;
					}
					queue.add(hypernymNode);


					//the for loop will run for as many hypernyms there are. 
					//Hypernyms are appended to the list and the loop keeps running
					//will keep track of ones not done because done ones are behind
					
				}
				if (tree.getCategory() != null)	{
						break;
					}
			}

			if (tree.getCategory() != null)	{
				System.out.println("\nCommon Category: \n============ \n" + tree.getCategory().getWordString() + "\n");
				System.out.println("From leaves: ");
				tree.getCategory().printRoots();
				break;
			}
		} while (queue.peek() != null);

		// tree.printTree();
		// hypernymTreeNode toFind = tree.findNode("food");
		// if (toFind != null)	{
		// 	toFind.printRoots();
		// }
		// else {
		// 	System.out.println("Couldn't find word");
		// }
	

    }


  

}

// CC Coordinating conjunction
// CD Cardinal number
// DT Determiner
// EX Existential there
// FW Foreign word
// IN Preposition or subordinating conjunction
// JJ Adjective
// JJR Adjective, comparative
// JJS Adjective, superlative
// LS List item marker
// MD Modal
// NN Noun, singular or mass
// NNS Noun, plural
// NNP Proper noun, singular
// NNPS Proper noun, plural
// PDT Predeterminer
// POS Possessive ending
// PRP Personal pronoun
// PRP$ Possessive pronoun
// RB Adverb
// RBR Adverb, comparative
// RBS Adverb, superlative
// RP Particle
// SYM Symbol
// TO to
// UH Interjection
// VB Verb, base form
// VBD Verb, past tense
// VBG Verb, gerund or present participle
// VBN Verb, past participle
// VBP Verb, non­3rd person singular present
// VBZ Verb, 3rd person singular present
// WDT Wh­determiner
// WP Wh­pronoun
// WP$ Possessive wh­pronoun
// WRB Wh­adverb

/*












*/

		